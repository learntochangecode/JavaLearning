# 异常

## java异常处理机制

* java中所有错误的超类为:Throwable。其下有两个子类:Error和Exception
* Error的子类描述的都是系统错误，比如虚拟机内存溢出等。
* Exception的子类描述的都是程序错误，比如空指针，下表越界等。
* 通常我们程序中处理的异常都是Exception。

异常处理机制关注的是:明知道程序可能出现某种错误，但是该错误无法通过修改逻辑完全规避掉时，我们会使用异常处理机制，在出现该错误是提供一种补救办法。

## try-catch

### 语法

```
语法:
try{
    代码片段...
}catch(XXXException e){
    出现错误后的补救措施(B计划)
}
```

### 机制

当某句代码抛出了一个异常时，JVM会做如下操作:
1:检查报错这句话是否有被异常处理机制控制(有没有try-catch)。如果有，则执行对应的catch操作，如果没有catch可以捕获该异常则视为没有异常处理动作。
2:如果没有异常处理，则异常会被抛出，由调用当前方法的代码片段处理该异常。

当try中某句代码报错后，就会跳出try执行下面对应的catch块，执行后就会退出catch继续向后执行，因此try语句块中报错代码以下的内容都不会被执行。

当try语句块中可能出现的几种不同异常对应的处理办法相同时，可以采取合并catch的做法，用同一个catch来捕获这几种可能出现的异常，而执行措施使用同一个。

```
try{
    String str = null;
    System.out.println(str.length());
}
catch(NullPointerException|StringIndexOutOfBoundsException e){
    System.out.println("处理空指针或下标越界!");

```

如果多个catch捕获的异常之间存在继承关系时，一定是子类异常在上超类异常在下。

```
try{
    String str = "";
    System.out.println(str.charAt(0));
}
catch(NullPointerException|StringIndexOutOfBoundsException e){
    System.out.println("处理空指针或下标越界!");
catch(Exception e){
    System.out.println("不知道咋回事但是报异常了");
```

## finally块

finally块是异常处理机制中的最后一块

* finally可以直接跟在try语句块之后
* finally可以跟在**最后一个**catch块之后
* fianlly下面不能再定义catch块

### 特点

只要程序执行到异常处理机制中(执行到try语句块中)，无论try中的代码是否出现异常，finally最终都**必定执行**

### 作用

通常用来执行释放资源这一类操作。例如IO操作完毕后的流关闭。

## 自动关闭特性

JDK7之后java推出了一个新特性:自动关闭特性可以更优雅的在异常处理机制中关闭IO

```
try(
   声明并初始化IO对象
){
   IO操作
}catch(IOException e){  //catch各种IO异常
   ...
}
```

## throw关键字

throw用来对外主动抛出一个异常，通常下面两种情况我们主动对外抛出异常:

* 当程序遇到一个满足语法，但是不满足业务要求时，可以抛出一个异常告知调用者。
* 程序执行遇到一个异常，但是该异常不应当在当前代码片段被解决时可以抛出给调用者。

## throws关键字

throws用来在声明方法时同时声明该方法可能抛出的异常，用于通知调用方添加处理该异常的手段。

当一个方法中使用throw抛出一个非RuntimeException的异常时，就要在该方法上使用throws声明这个异常的抛出。此时调用该方法的代码就必须处理这个异常，否则编译不通过。

当我们调用一个含有throws声明异常抛出的方法时，编译器要求我们必须处理这个异常，否则编译不通过。 处理手段有两种:

* 使用try-catch捕获并处理这个异常
* 在当前方法上继续使用throws声明该异常的抛出给调用者解决。 具体选取那种取决于异常处理的责任问题。
* **注意，永远不应当在main方法上使用throws!!**

### throws的重写规则

当一个子类重写超类含有throws声明异常抛出的方法时，针对throws的重写规则

* **允许**不再抛出任何异常
* **允许**仅抛出部分异常
* **允许**抛出超类方法声明抛出异常的子类型异常
* **不允许**抛出额外异常(超类方法没有声明的且不存在继承关系的)
* **不允许**抛出超类方法抛出异常的超类型异常

## 异常分类

### Java异常可以分为可检测异常，非检测异常：

* **可检测异常**：可检测异常经编译器验证，对于声明抛出异常的任何方法，编译器将强制执行处理或声明规则，不捕捉这个异常，编译器就通不过，不允许编译
* **非检测异常**：非检测异常不遵循处理或者声明规则。在产生此类异常时，不一定非要采取任何适当操作，编译器不会检查是否已经解决了这样一个异常
* **RuntimeException** 类属于非检测异常，因为普通JVM操作引起的运行时异常随时可能发生，此类异常一般是由特定操作引发。但这些操作在java应用程序中会频繁出现。因此它们不受编译器检查与处理或声明规则的限制。**实际上RuntimeException及其子类型表达的都是因为程序漏洞(BUG),即:逻辑不严谨等原因导致的。这类异常都是通过修复代码可完全避免的异常，因此不应当由异常处理机制来处理**

### 常见的RuntimeException子类

* IllegalArgumentException：抛出的异常表明向方法传递了一个不合法或不正确的参数
* NullPointerException：当应用程序试图在需要对象的地方使用 null 时，抛出该异常
* ArrayIndexOutOfBoundsException：当使用的数组下标超出数组允许范围时，抛出该异常
* ClassCastException：当试图将对象强制转换为不是实例的子类时，抛出该异常
* NumberFormatException：当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。

## 异常API

Exception上有一些常用的方法

* void printStackTrace():用于输出当前异常的堆栈跟踪信息
  便于程序员找到错误根源，分析错误原因制定B计划
* String getMessage():用于获取当前错误消息
  多用于提示给用户或记录日志使用

## 自定义异常

自定义异常通常用来定义那些业务上的异常问题。

定义自定义异常需要注意以下问题:

* 异常的类名要做到见名知义
* 需要是Exception的子类
* 提供超类异常提供的所有种类构造器
